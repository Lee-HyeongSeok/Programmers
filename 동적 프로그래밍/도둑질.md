## :round_pushpin: 동적 프로그래밍 - 도둑질

***

인접한 집은 도둑질 하지 못 한다는 전제에서, 각 집 마다 돈이 담긴 배열이 주어질 때 도둑이 훔칠 수 있는 돈의 최댓값을 리턴하는 문제



### :pushpin: 풀이

- 각 배열의 원소마다 가질 수 있는 최대 값을 결정

[1, 10, 20, 4, 40] 배열이 있을 때,

각 현재 위치에서 선택할 수 있는 최선의 경우를 누적하면서 연산하는 것이 포인트



- 처음 1의 위치
  - 자기 자신이 최선의 경우
- 두 번째 10의 위치
  - 1과 자신을 비교하여 10을 선택하게 됨
- 세 번째 20의 위치
  - 10을 선택하면 자기 자신을 선택할 수 없음
  - 1을 선택했을 때의 누적합을 자기 자신과 더하는 수 밖에 없음
- 네 번째 4의 위치
  - 20의 위치를 선택한다면(20을 선택했을 때의 누적 합) 자기 자신이 값에 더해질 수 없다
  - 10을 선택했을 때, 10의 위치에 존재하는 누적합과 자기 자신과 더해서 14라는 결과가 나온다.
  - 20을 선택했을 때의 값이 더 크므로 20을 선택하고, 20의 위치에 존재하는 누적합 21을 4의 위치에 기록한다.

이러한 방식을 사용하여

```현재 위치 값 = MAX(현재 위치 - 1, 현재 위치 - 2에 존재하는 값 + 현재 위치 값)```

이라는 규칙을 찾을 수 있다.



하지만,

단순 배열이 아닌, 원형 탐색이므로 위 케이스만 고려하게 되면 마지막 값은 고를 수 없게 된다.

- 원형 탐색의 시작점을 고려하면, 끝점은 선택하지 못 한다
- 끝점을 고려하면, 시작점은 선택하지 못 한다.

이러한 논리적 오류를 해결하기 위해

- 시작점을 고려하되 마지막을 선택하지 않는 경우
- 마지막을 고려하되 시작을 선택하지 않는 경우

두 가지로 나누어서 문제를 해결해야 한다.



[1, 10, 20, 4, 40]의 배열을

[1, 10, 2, 4, 0] 과 [0, 10, 20, 4, 40] 으로 나눈다.

위는 끝점을 0으로 만든 배열과 시작점을 0으로 만든 배열이다.





```c++
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

int solution(vector<int> money) {
    int LHS_DP[money.size() + 1];
    
    LHS_DP[0] = money[0];
    LHS_DP[1] = max(money[0], money[1]);
    
    int lhs_max = 0, rhs_max = 0;
    
    for(int i=2; i<money.size()-1; ++i)
    {
        LHS_DP[i] = max(LHS_DP[i - 1], LHS_DP[i - 2] + money[i]);
        if(lhs_max < LHS_DP[i]) lhs_max = LHS_DP[i];
    }
    
    int RHS_DP[money.size() + 1];
    RHS_DP[0] = 0;
    RHS_DP[1] = money[1];
    
    for(int i=2; i<money.size(); ++i)
    {
        RHS_DP[i] = max(RHS_DP[i - 1], RHS_DP[i - 2] + money[i]);
        if(rhs_max < RHS_DP[i]) rhs_max = RHS_DP[i];
    }
    
    return max(lhs_max, rhs_max);
}
```

